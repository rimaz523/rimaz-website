import { Component, inject } from '@angular/core'
import { DomSanitizer, SafeHtml } from '@angular/platform-browser'

@Component({
  selector: 'rmz-article',
  imports: [],
  templateUrl: './article.component.html',
  styleUrl: './article.component.scss',
})
export class ArticleComponent {
  private sanitizer = inject(DomSanitizer)
  title = 'Running a .NET Core 9.0 API with SQL Server Seamlessly Using Docker Containers'
  content =
    '\n\u003Cp id=\"7b09\"\u003EIn this article, I will demonstrate how to run a .NET Core 9.0 API application inside a Docker container and connect it to another container running SQL Server. For this demo, I will use Docker Desktop.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:493/1*lPLK3FHxQKwHwqZZuQCKUQ.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"aff6\"\u003E\u003Cstrong\u003EThe steps we’ll follow are:\u003C/strong\u003E\u003C/p\u003E\n\n\n\n\u003Col class=\"wp-block-list\"\u003E\n\u003Cli\u003ERunning a .NET Core Web API application locally.\u003C/li\u003E\n\n\n\n\u003Cli\u003EDockerizing the Web API application and running it using Docker Desktop.\u003C/li\u003E\n\n\n\n\u003Cli\u003ECreating a db container using the SQL Server 2019 image from Docker Hub.\u003C/li\u003E\n\n\n\n\u003Cli\u003EConnecting to db container using Visual Studio\u003C/li\u003E\n\n\n\n\u003Cli\u003E\u003Cmark\u003EUpdating the Docker Compose file to network both containers.\u003C/mark\u003E\u003C/li\u003E\n\u003C/ol\u003E\n\n\n\n\u003Ch3 class=\"wp-block-heading\" id=\"0865\"\u003ERunning a .NET Core Web API application locally\u003C/h3\u003E\n\n\n\n\u003Cp id=\"55de\"\u003E\u003Cstrong\u003EPrerequisite :&nbsp;\u003C/strong\u003Eensure you have the .net core 9.0 sdk installed on your machine ( I will be using Windows OS)&nbsp;\u003Ca href=\"https://dotnet.microsoft.com/en-us/download/dotnet\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttps://dotnet.microsoft.com/en-us/download/dotnet\u003C/a\u003E\u003C/p\u003E\n\n\n\n\u003Cp id=\"3767\"\u003EHere we will be running a clean architecture api solution template I’ve created in nuget.org&nbsp;\u003Ca href=\"https://www.nuget.org/packages/Clean.Lean.Architecture.WebApi.AspNetCore.Solution.Template\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttps://www.nuget.org/packages/Clean.Lean.Architecture.WebApi.AspNetCore.Solution.Template\u003C/a\u003E\u003C/p\u003E\n\n\n\n\u003Cp id=\"1a88\"\u003ERun the following command to install this template :\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003Edotnet new install Clean.Lean.Architecture.WebApi.AspNetCore.Solution.Template::9.1.0\u003C/pre\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*irU3ZrUvHmHI3LMk8ARybA.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"8f52\"\u003EOnce installation is complete, we can go ahead and spin up our dotnet core 9.0 web api app using the following command :\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003Edotnet new cla-sln --name YourSolutionName\u003C/pre\u003E\n\n\n\n\u003Cp id=\"fb8a\"\u003EI will be calling my api solution&nbsp;\u003Ccode\u003Emyapp\u003C/code\u003E\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003Edotnet new cla-sln --name myapp\u003C/pre\u003E\n\n\n\n\u003Cp id=\"658b\"\u003EOnce the app creation is complete, change directory to&nbsp;\u003Ccode\u003Emyapp/src/WebApi/\u003C/code\u003E\u003C/p\u003E\n\n\n\n\u003Cp id=\"d27d\"\u003EAnd run the following command to build and run your app :\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003Edotnet run\u003C/pre\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*jlZnOs6oFWLCzumTFV2RAg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"f7c1\"\u003EYou can see the ports the app is running on here\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*N8XU08lm8IBSCEn75trHRg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"dbb2\"\u003EAs this is an API app, visiting&nbsp;\u003Ca href=\"https://localhost:7292/\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttps://localhost:7292\u003C/a\u003E&nbsp;will give you a 404. Instead go to&nbsp;\u003Ca href=\"https://localhost:7292/swagger/\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttps://localhost:7292/swagger/\u003C/a\u003E&nbsp;to open up the swagger API\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*zFP4NQo4zzCPCMAwHNZCtA.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"d3b9\"\u003EYou can now try out the GET and POST requests here. What we are most interested in is the&nbsp;\u003Cstrong\u003EGET /api/BlogPreviews\u003C/strong\u003E&nbsp;api, as this returns us blog data from a SQL Local DB file.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*9lwjYBT2YPokQQ26zDeyFw.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"717b\"\u003EWe now have a .net core 9.0 application running locally on our machine.\u003C/p\u003E\n\n\n\n\u003Ch3 class=\"wp-block-heading\" id=\"a015\"\u003EDockerizing the Web API application and running it using Docker Desktop\u003C/h3\u003E\n\n\n\n\u003Cp id=\"b98b\"\u003E\u003Cstrong\u003EPrerequisite :&nbsp;\u003C/strong\u003EEnsure you have Docker desktop installed locally (See :&nbsp;\u003Ca href=\"https://docs.docker.com/desktop/setup/install/windows-install/\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttps://docs.docker.com/desktop/setup/install/windows-install/\u003C/a\u003E)\u003C/p\u003E\n\n\n\n\u003Cp id=\"d644\"\u003EContainerizing your .net core web api app can be quickly done by running the\u003Ccode\u003Edocker init\u003C/code\u003E&nbsp;command at the root of your api solution.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*EAWdhEqmvhd5aUeTTZDCMg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"8aa1\"\u003EOnce you run docker init, you will be asked a number of questions regarding your application platform and version of dotnet among other things as you can see from the screenshot above.\u003C/p\u003E\n\n\n\n\u003Cp id=\"d3c6\"\u003EChoose ASP.NET Core as your application platform.\u003C/p\u003E\n\n\n\n\u003Cp id=\"3d94\"\u003EIn our case select the WebApi project which is our startup project in our solution.\u003C/p\u003E\n\n\n\n\u003Cp id=\"9b96\"\u003EFor .NET version select 9.0\u003C/p\u003E\n\n\n\n\u003Cp id=\"ab70\"\u003EI’ve also set the port to be 8080.\u003C/p\u003E\n\n\n\n\u003Cp id=\"e66a\"\u003EOnce&nbsp;\u003Ccode\u003Edocker init\u003C/code\u003E&nbsp;completes, it will create you 4 files\u003C/p\u003E\n\n\n\n\u003Cul class=\"wp-block-list\"\u003E\n\u003Cli\u003E.dockerignore — this file will contain patterns to files and dirs that should be ignored when creating your docker container or image.\u003C/li\u003E\n\n\n\n\u003Cli\u003EDockerfile — this contains the steps to build your docker container.\u003C/li\u003E\n\n\n\n\u003Cli\u003Ecompose.yml- contains the services that will be run.\u003C/li\u003E\n\n\n\n\u003Cli\u003EREADME.Docker.md- a readme file for your containerization details.\u003C/li\u003E\n\u003C/ul\u003E\n\n\n\n\u003Cp id=\"28cf\"\u003ENow, let’s use the&nbsp;\u003Ccode\u003Edocker compose up\u003C/code\u003E&nbsp;command in the root directory of our solution. This will execute the&nbsp;\u003Ccode\u003Ecompose.yaml\u003C/code\u003E&nbsp;file, which defines a single service: our API server. The build configuration for the service is specified in the&nbsp;\u003Ccode\u003EDockerfile\u003C/code\u003E. (NOTE : you can run&nbsp;\u003Ccode\u003Edocker compose up -d\u003C/code\u003Eto run this command in detached mode)\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*MeFztuw4qioB6ArkIQE-lQ.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"506d\"\u003EYou can now access the api server by going to&nbsp;\u003Ca href=\"http://localhost:8080/swagger/index.html\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttp://localhost:8080/swagger/index.html\u003C/a\u003E\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*Zw0EF7E8nJjrshii_QtcdA.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"21e4\"\u003EHowever if you run the&nbsp;\u003Cstrong\u003EGET /api/BlogPreviews\u003C/strong\u003E&nbsp;API request, you will get a&nbsp;\u003Cstrong\u003E500 internal error\u003C/strong\u003E.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*1ddmcltse83saZhZClEffA.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"f811\"\u003EYou can view the logs in docker desktop. As you can see below the error is related to System Globalization functionality in dotnet.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*9SG-NE2LFDqCDKmxwfWEcg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"e13b\"\u003EYou need to add the following code in your Dockerfile to fix this :\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003EENV \\\u003Cbr\u003E    DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=false \\\u003Cbr\u003E    LC_ALL=en_US.UTF-8 \\\u003Cbr\u003E    LANG=en_US.UTF-8\u003Cbr\u003E\u003Cbr\u003ERUN apk add --no-cache \\\u003Cbr\u003E    icu-data-full \\\u003Cbr\u003E    icu-libs\u003C/pre\u003E\n\n\n\n\u003Cp id=\"3aa8\"\u003EUpdate the final image of the Dockerfile in the root of your solution with the above code.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/1*Zyjm8Yf7naNcqizBm8vmog.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"c241\"\u003EYou can read more about enabling Globalization for Alpine images here :&nbsp;\u003Ca href=\"https://github.com/dotnet/dotnet-docker/blob/main/samples/enable-globalization.md#alpine-images\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttps://github.com/dotnet/dotnet-docker/blob/main/samples/enable-globalization.md#alpine-images\u003C/a\u003E\u003C/p\u003E\n\n\n\n\u003Cp id=\"b496\"\u003EOnce you add this, run&nbsp;\u003Ccode\u003Edocker compose down\u003C/code\u003E&nbsp;to remove your app container.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*QVcY3a-aoCSaJBXThWqYOw.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"4e82\"\u003EAlso run&nbsp;\u003Ccode\u003Edocker image rm &lt;your-image-name&gt;\u003C/code\u003E&nbsp;to remove the image docker created for your app. The image name will be the root dir name hyphenated with the service name (in our case server) in our compose.yaml file. You can see all images in your machine by running the&nbsp;\u003Ccode\u003Edocker images\u003C/code\u003E&nbsp;command.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*64VFcPGiWWrYYPxeimybBg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"0d22\"\u003EOnce these steps are complete, run&nbsp;\u003Ccode\u003Edocker compose up\u003C/code\u003E&nbsp;once again to rebuild your api container.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*dfoDrqzzrbSsfwc276Kl_w.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"5a24\"\u003ENow when you try accessing&nbsp;\u003Cstrong\u003EGET /api/BlobPreviews\u003C/strong\u003E&nbsp;you will be hit with a new exception which mentions that LocalDB is not supported. And this is okay as we are NOT interested in LocalDB anyway. Instead, we’ll create a SQL Server container using an image from Docker Hub and configure our application to connect to it.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*uuXuGrK2rJCtLM2vNx1xiQ.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Ch3 class=\"wp-block-heading\" id=\"5b51\"\u003ECreating a db container using the SQL Server 2019 image from Docker Hub\u003C/h3\u003E\n\n\n\n\u003Cp id=\"ea73\"\u003ELets now run a sql server 2019 databse server image in a container. For this lets add the following lines to our&nbsp;\u003Ccode\u003Ecompose.yaml\u003C/code\u003E&nbsp;file under the&nbsp;\u003Ccode\u003Eservices\u003C/code\u003E&nbsp;section. I’m exposing the container on localhost using port 8095.\u003C/p\u003E\n\n\n\n\u003Cp id=\"83df\"\u003EYou can find the list of SQL server images here :&nbsp;\u003Ca href=\"https://hub.docker.com/r/microsoft/mssql-server\" rel=\"noreferrer noopener\" target=\"_blank\"\u003Ehttps://hub.docker.com/r/microsoft/mssql-server\u003C/a\u003E\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003Esqldatabase:\u003Cbr\u003E    image: mcr.microsoft.com/mssql/server:2019-latest\u003Cbr\u003E    container_name: sqldatabase\u003Cbr\u003E    ports:\u003Cbr\u003E      - \"8095:1433\"\u003Cbr\u003E    environment:\u003Cbr\u003E      - ACCEPT_EULA=Y\u003Cbr\u003E      - SA_PASSWORD=${DATABASE_PASSWORD}\u003Cbr\u003E    restart: always\u003C/pre\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*BD3xJIy0XrIhD-e-rgSsag.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"9965\"\u003EAs you can see above, I’ve set the database password as an environment variable. You can set this value as an environment variable in the powershell command line before invoking&nbsp;\u003Ccode\u003Edocker compose up\u003C/code\u003E\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003E$env:DATABASE_PASSWORD = \"MyTe&amp;TP@88wor^\"\u003Cbr\u003Edocker compose up\u003C/pre\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*0JpENb2mg5GHMqN4YyNMEQ.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"1016\"\u003ELets now try connecting to this db container using Microsoft SQL Server Management Studio (SSMS) on our local machine.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*zEnwTrrdzowAX4JEKSYT3g.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"a824\"\u003EFor Server name specify&nbsp;\u003Ccode\u003Etcp:localhost,8095\u003C/code\u003E\u003C/p\u003E\n\n\n\n\u003Cp id=\"738f\"\u003EWe will be using SQL Server Authentication with Login&nbsp;\u003Ccode\u003Esa\u003C/code\u003E&nbsp;which is the default in these container images and the password we set as the env variable. In our case it is MyTe&amp;TP@88wor^\u003C/p\u003E\n\n\n\n\u003Cp id=\"a6e4\"\u003ELets create a test database in the container now.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*a-SaV6s0WRQMzpNPljKPZw.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"8c6d\"\u003EIf you now run&nbsp;\u003Ccode\u003Edocker compose down\u003C/code\u003E&nbsp;to tear down the containers followed by&nbsp;\u003Ccode\u003Edocker compose up\u003C/code\u003E&nbsp;you will notice that the DB we created is missing. this is because we haven’t used Voloumes to persist any data yet. Lets do that now.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*6ZAyNHV49MsA8qzTfx9sbQ.png\" alt=\"\"/\u003E\u003Cfigcaption class=\"wp-element-caption\"\u003ETearing down and rebuilding our containers\u003C/figcaption\u003E\u003C/figure\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*vLT8DRRCIEJHFCxRCDuWfw.png\" alt=\"\"/\u003E\u003Cfigcaption class=\"wp-element-caption\"\u003EtestDB is now missing\u003C/figcaption\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"be38\"\u003EI’ve now defined a new Volume&nbsp;\u003Ccode\u003Esqldatabase_data\u003C/code\u003E&nbsp;and mapped that to our database container so that any data written to this container will be preserved in this volume even if the container is destroyed using&nbsp;\u003Ccode\u003Edocker compose down\u003C/code\u003E\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*ZtyDr5UJ436ZT3l2fTEfzQ.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"ce80\"\u003EYou can find the updated&nbsp;\u003Ccode\u003Ecompose.yaml\u003C/code\u003E&nbsp;below\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003Evolumes:\u003Cbr\u003E  sqldatabase_data:\u003Cbr\u003E\u003Cbr\u003Eservices:\u003Cbr\u003E  server:\u003Cbr\u003E    build:\u003Cbr\u003E      context: .\u003Cbr\u003E      target: final\u003Cbr\u003E    ports:\u003Cbr\u003E      - 8080:8080\u003Cbr\u003E  sqldatabase:\u003Cbr\u003E    image: mcr.microsoft.com/mssql/server:2019-latest\u003Cbr\u003E    container_name: sqldatabase\u003Cbr\u003E    ports:\u003Cbr\u003E      - \"8095:1433\"\u003Cbr\u003E    environment:\u003Cbr\u003E      - ACCEPT_EULA=Y\u003Cbr\u003E      - SA_PASSWORD=${DATABASE_PASSWORD}\u003Cbr\u003E    restart: always\u003Cbr\u003E    volumes:\u003Cbr\u003E      - sqldatabase_data:/var/opt/mssql\u003C/pre\u003E\n\n\n\n\u003Cp id=\"5ab0\"\u003ERecreating our containers now :\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*N4PlAZpOmAYugOaIaA1xTA.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"07d0\"\u003EConnecting to SSMS and creating a new database&nbsp;\u003Ccode\u003EtestPersistingDB\u003C/code\u003E\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*UoipGqAnN-WUkSl0CLAvPw.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"982f\"\u003EStopping, tearing down and recreating our containers next to verify :\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*Ngo56qd8k1UCkPn8IfEgpg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"d894\"\u003ENow reconnect to SSMS and you will see that the database still exists\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*b5SPRyYIFF0y0nkIjzhMXg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Ch3 class=\"wp-block-heading\" id=\"4b99\"\u003EConnecting to db container using Visual Studio\u003C/h3\u003E\n\n\n\n\u003Cp id=\"7e38\"\u003EWe will now look at how to connect our dotnet core 9.0 app running locally using Visual Studio to the database container&nbsp;\u003Ccode\u003Esqldatabase\u003C/code\u003E&nbsp;that we just created.\u003C/p\u003E\n\n\n\n\u003Cp id=\"aa25\"\u003ETo do this open up the app using Visual Studio and go to the&nbsp;\u003Ccode\u003Eappsettings.json\u003C/code\u003E&nbsp;file found in&nbsp;\u003Cstrong\u003E\\myapp\\src\\WebApi\\\u003C/strong\u003E\u003C/p\u003E\n\n\n\n\u003Cp id=\"4e85\"\u003EUpdate the&nbsp;\u003Ccode\u003ESqlServerConnectionString\u003C/code\u003E&nbsp;value to be the following:\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003E\"Persistence\": {\u003Cbr\u003E    \"SqlServerConnectionString\": \"Server=tcp:localhost,8095;Database=myapp-db;User Id=sa;Password=MyTe&amp;TP@88wor^;TrustServerCertificate=True;\"\u003Cbr\u003E  }\u003C/pre\u003E\n\n\n\n\u003Cp id=\"889d\"\u003ESince we are connecting from our local machine, the sql server credentials will be similar to the values we used when connecting using SQL Server Management Studio (SSMS). You also need to set&nbsp;\u003Ccode\u003ETrustServerCertificate\u003C/code\u003E&nbsp;to True. We will call our database&nbsp;\u003Ccode\u003Emyapp-db\u003C/code\u003E.\u003C/p\u003E\n\n\n\n\u003Cp id=\"7bf4\"\u003ESave and Run using Visual Studio.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*Tq-JhVWKUizGLGPvYCvfCg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"f152\"\u003EYou will notice that Entity Framework created some tables and some data was seeded.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*9vu6VtOxcjAYnnKdQqpYwg.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"93aa\"\u003ERunning&nbsp;\u003Cstrong\u003EGET /api/BlogPreviews\u003C/strong\u003E&nbsp;will return data from our db container.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*pJh9yMjh4xZfA5fehhUx5A.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"ac3c\"\u003EConnecting to the db container using SSMS will also now show you the new database&nbsp;\u003Ccode\u003Emyapp-db\u003C/code\u003E&nbsp;and its contents\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*Yb0-SM-08jbKEqAIGdzr3g.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Ch3 class=\"wp-block-heading\" id=\"93ba\"\u003EUpdating the Docker Compose file to network both containers\u003C/h3\u003E\n\n\n\n\u003Cp id=\"98ec\"\u003EFinally its time to provide our server container access to the db container so that our app container running on docker can internally access the DB container. To do this we need to recreate the app image by updating the SQL server connection string and then add a bridge (default) network between the two containers to facilitate communication.\u003C/p\u003E\n\n\n\n\u003Cp id=\"d4b4\"\u003EFirst thing to do is update the Connection string once again in the&nbsp;\u003Ccode\u003Eappsettings.json\u003C/code\u003Efile of our app.\u003C/p\u003E\n\n\n\n\u003Cp id=\"07b6\"\u003EReplace&nbsp;\u003Ccode\u003Elocalhost\u003C/code\u003E&nbsp;with the container name of the sql server. In our case it is&nbsp;\u003Ccode\u003Esqldatabase\u003C/code\u003E. Also update the port from the external to the internal one. In our case we replace&nbsp;\u003Ccode\u003E8095\u003C/code\u003E&nbsp;with&nbsp;\u003Ccode\u003E1433\u003C/code\u003E. Everything else remains the same.\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003E\"Persistence\": {\u003Cbr\u003E  \"SqlServerConnectionString\": \"Server=tcp:sqldatabase,1433;Database=myapp-db;User Id=sa;Password=MyTe&amp;TP@88wor^;TrustServerCertificate=True;\"\u003Cbr\u003E}\u003C/pre\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*Pe1hIp63aLqieWo9CC59-A.png\" alt=\"\"/\u003E\u003Cfigcaption class=\"wp-element-caption\"\u003EContainer name and internal port specified in compose.yaml\u003C/figcaption\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"9658\"\u003ELets try recreating this image. And running it on a container to see what error we get if we run with just this change.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*jZvgWKa-A6iGlgCdogW_Rw.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"75a9\"\u003ENow when you try to access GET /api/BlogPreviews which needs to read data from the database container, you get a&nbsp;\u003Cstrong\u003E200 Success\u003C/strong\u003E&nbsp;with response data!&nbsp;\u003Cstrong\u003ENO ERRORS!\u003C/strong\u003E\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1155/1*d009hZqzqBIDmdUOW89l-w.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"e682\"\u003EBut how come? We never specified the networking between the containers in our compose.yaml?\u003C/p\u003E\n\n\n\n\u003Cp id=\"9c37\"\u003EIn docker compose, containers can communicate with each other by default if they are part of the same compose project. Even if you do not explicitly define a&nbsp;\u003Ccode\u003Enetwork\u003C/code\u003E&nbsp;in your&nbsp;\u003Ccode\u003Ecompose.yaml\u003C/code\u003E&nbsp;file, docker compose automatically creates a default bridge network for the project and connects all the containers to it.\u003C/p\u003E\n\n\n\n\u003Cp id=\"6622\"\u003EYou can see that if we run&nbsp;\u003Ccode\u003Edocker network ls\u003C/code\u003E&nbsp;we have a new bridge network&nbsp;\u003Ccode\u003Emyapp_default\u003C/code\u003Ecreated automatically by docker to network both our containers.\u003C/p\u003E\n\n\n\n\u003Cfigure class=\"wp-block-image\"\u003E\u003Cimg decoding=\"async\" src=\"https://miro.medium.com/v2/resize:fit:1130/1*AdWwNQlGPQAORJxcfLc4Yw.png\" alt=\"\"/\u003E\u003C/figure\u003E\n\n\n\n\u003Cp id=\"7aed\"\u003ETherefore there is no need to create a network yourself if all you are looking for is a simple bridge network. However if you want to explictly define your bridge network in the&nbsp;\u003Ccode\u003Ecompose.yaml\u003C/code\u003E, you can update it as follows :\u003C/p\u003E\n\n\n\n\u003Cpre class=\"wp-block-preformatted\"\u003Evolumes:\u003Cbr\u003E  sqldatabase_data:\u003Cbr\u003Enetworks:\u003Cbr\u003E  mynetwork:\u003Cbr\u003Eservices:\u003Cbr\u003E  server:\u003Cbr\u003E    build:\u003Cbr\u003E      context: .\u003Cbr\u003E      target: final\u003Cbr\u003E    ports:\u003Cbr\u003E      - 8080:8080\u003Cbr\u003E    networks:\u003Cbr\u003E      - mynetwork\u003Cbr\u003E  sqldatabase:\u003Cbr\u003E    image: mcr.microsoft.com/mssql/server:2019-latest\u003Cbr\u003E    container_name: sqldatabase\u003Cbr\u003E    ports:\u003Cbr\u003E      - \"8095:1433\"\u003Cbr\u003E    environment:\u003Cbr\u003E      - ACCEPT_EULA=Y\u003Cbr\u003E      - SA_PASSWORD=${DATABASE_PASSWORD}\u003Cbr\u003E    restart: always\u003Cbr\u003E    volumes:\u003Cbr\u003E      - sqldatabase_data:/var/opt/mssql\u003Cbr\u003E    networks:\u003Cbr\u003E      - mynetwork\u003C/pre\u003E\n\n\n\n\u003Cp id=\"8aab\"\u003EHappy coding!\u003C/p\u003E\n\n\n\n\u003Cp\u003E\u003C/p\u003E\n"'
  getSanitizedContent(content: string): SafeHtml {
    return this.sanitizer.bypassSecurityTrustHtml(content)
  }
}
